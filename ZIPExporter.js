// Generated by CoffeeScript 1.3.3
(function() {
  var ZIPExporter,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ZIPExporter = (function() {

    function ZIPExporter() {}

    ZIPExporter.prototype["export"] = function(storage, cb) {
      var _this = this;
      this.zip = new JSZip();
      this.assets = this.zip.folder('assets');
      return this._export(storage, function(err) {
        var zipFileLink;
        if (err != null) {
          return cb(err);
        }
        _this.zip.file("content.json", JSON.stringify(_this.data));
        zipFileLink = "data:application/zip;base64," + _this.zip.generate({
          base64: true,
          compression: 'STORE'
        });
        return cb(null, zipFileLink);
      });
    };

    ZIPExporter.prototype._export = function(storage, cb) {
      var _this = this;
      this.data = {};
      this.storage = storage;
      return this.storage.get("root", function(err, rootDoc) {
        var rootNodeId;
        if (err != null) {
          return cb(err);
        }
        rootNodeId = (rootDoc != null ? rootDoc.value : void 0) || null;
        console.log("### Start exporting with rootNodeId", rootNodeId);
        if (!(rootNodeId != null)) {
          return cb("rootNodeId not found");
        }
        _this.q = async.queue(function(id, cb) {
          return _this._visitNode(id, cb);
        }, 3);
        _this.q.drain = function() {
          console.log("finished exporting");
          console.log(_this.data);
          return cb(null);
        };
        return _this.q.push(rootNodeId, function(err, nodeId) {
          return console.log("finished exporting root (id=" + nodeId + ") with error " + err);
        });
      });
    };

    ZIPExporter.prototype._visitNode = function(nodeId, cb) {
      var _this = this;
      return async.parallel([
        function(cb) {
          return _this.storage.get("node_" + nodeId + "_cells", cb);
        }, function(cb) {
          return _this.storage.get("node_" + nodeId + "_children", cb);
        }
      ], function(err, results) {
        var cellId, cells, childNodeId, children, position, q, _results;
        if (err != null) {
          return cb(err);
        }
        cells = results[0], children = results[1];
        if ((children != null) && !_.isEmpty(children)) {
          console.log("Start exporting node " + nodeId + "'s children");
          _this.data["node_" + nodeId + "_children"] = children;
          for (position in children) {
            if (!__hasProp.call(children, position)) continue;
            childNodeId = children[position];
            console.log("starting exporting node " + childNodeId);
            _this.q.push(childNodeId, function(err, nodeId) {
              return console.log("finished exporting node " + nodeId + " with error " + err);
            });
          }
        }
        if ((cells != null) && !_.isEmpty(cells)) {
          console.log("Start exporting node " + nodeId + "'s cells");
          _this.data["node_" + nodeId + "_cells"] = cells;
          q = async.queue(function(id, cb) {
            var key;
            key = "cell_" + id;
            console.log("getting data of " + key);
            return _this.storage.get(key, function(err, doc) {
              if ((doc != null) && !_.isEmpty(doc)) {
                _this.data[key] = doc;
                return _this.handleCellData(id, doc, cb);
              } else {
                return cb(err, nodeId);
              }
            });
          }, 3);
          q.drain = function() {
            console.log("Done exporting node " + nodeId + "'s cells");
            return cb(null, nodeId);
          };
          _results = [];
          for (position in cells) {
            if (!__hasProp.call(cells, position)) continue;
            cellId = cells[position];
            _results.push(q.push(cellId, function(err, cellId) {
              return console.log("finished getting cell " + cellId + " with error " + err);
            }));
          }
          return _results;
        } else {
          return cb(null, nodeId);
        }
      });
    };

    ZIPExporter.prototype.handleCellData = function(cellId, doc, cb) {
      var gotSomethingQueued, ignoreKeys, isExternalURI, k, q, v, _fn,
        _this = this;
      gotSomethingQueued = false;
      q = async.queue(function(url, cb) {
        console.log("downloading " + url + " ...");
        return $.ajax({
          url: url,
          dataType: "text",
          beforeSend: function(x) {
            if (x != null ? x.overrideMimeType : void 0) {
              return x.overrideMimeType('text/plain; charset=x-user-defined');
            }
          },
          error: function(jqXHR, textStatus, errorThrown) {
            return cb(errorThrown);
          },
          success: function(data, textStatis, xhr) {
            var cleanData, code, x, _i, _ref;
            cleanData = "";
            for (x = _i = 0, _ref = data.length; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
              code = data.charCodeAt(x) & 0xff;
              cleanData += String.fromCharCode(code);
            }
            return cb(null, {
              data: cleanData,
              contentType: xhr.getResponseHeader("content-type")
            });
          }
        });
      }, 3);
      q.drain = function() {
        console.log("Finished downloading assets of cell " + cellId);
        return cb(null, cellId);
      };
      ignoreKeys = ["label"];
      isExternalURI = function(uri) {
        return uri.substr(0, 5) === "http:";
      };
      _fn = function(k, v) {
        if (isExternalURI(v)) {
          gotSomethingQueued = true;
          return q.push(v, function(err, o) {
            var extension, filename;
            if (err != null) {
              return console.log("download ended with error " + err);
            } else {
              console.log("received " + o.data.length + " bytes " + (o.data.substr(1, 3)));
              filename = "cell_" + cellId + "_" + k;
              extension = window.mimeTypes[o.contentType || "text/plain"];
              filename += "." + extension;
              _this.assets.file(filename, o.data, {
                base64: false,
                binary: true
              });
              return doc[k] = "./assets/" + filename;
            }
          });
        }
      };
      for (k in doc) {
        v = doc[k];
        if (__indexOf.call(ignoreKeys, k) >= 0) {
          continue;
        }
        _fn(k, v);
      }
      if (!gotSomethingQueued) {
        return cb(null, cellId);
      }
    };

    return ZIPExporter;

  })();

  window.ZIPExporter = ZIPExporter;

}).call(this);
